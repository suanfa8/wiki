> 专题名称：使用「广度优先遍历」

# 第 1 节：齐头并进的广度优先遍历

![image.png](https://pic.leetcode-cn.com/1611483686-FJqdzm-image.png)

我们依然用走迷宫的例子向大家展示「广度优先遍历」的思想。

![广度搜索迷宫(1).mp4](bac88acb-b81b-4596-89ad-99115a2b2dd1)

「广度优先遍历」的思想在生活中随处可见：

+ 如果我们要找一个医生或者律师，我们会先在自己的一度人脉中遍历（查找），如果没有找到，继续在自己的二度人脉中遍历（查找），直到找到为止。

<![image.png](https://pic.leetcode-cn.com/1609662684-tkAwUf-image.png),![image.png](https://pic.leetcode-cn.com/1609662687-hCCwMq-image.png),![image.png](https://pic.leetcode-cn.com/1609662692-gWXpzs-image.png)>

+ 把一块石头投入平静的水面，激起的一层一层波纹就呈现「广度优先遍历」的特点。

![水波纹效果1.mp4](d546ce30-c9c5-4fd7-8764-cc22c035bd14)

---

## 广度优先遍历借助「队列」实现

广度优先遍历呈现出「一层一层向外扩张」的特点，**先看到的结点先遍历，后看到的结点后遍历**，因此「广度优先遍历」可以借助「队列」实现。

![11-01-05.gif](https://pic.leetcode-cn.com/1609663109-jjxZav-11-01-05.gif)

**说明**：遍历到一个结点时，如果这个结点有左（右）孩子结点，依次将它们加入队列。

> 友情提示：广度优先遍历的写法相对固定，我们不建议大家背代码、记模板。在深刻理解广度优先遍历的应用场景（找无权图的最短路径），借助「队列」实现的基础上，多做练习，写对代码就是自然而然的事情了。

我们先介绍「树」的广度优先遍历，再介绍「图」的广度优先遍历。事实上，它们是非常像的。

---

## 树的广度优先遍历

### 例 1：「力扣」第 102 题：二叉树的层序遍历（中等）

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例**：

二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

**思路分析**：

+ 题目要求我们一层一层输出树的结点的值，很明显需要使用「广度优先遍历」实现；
+ 广度优先遍历借助「队列」实现；

+ **注意**：

  + 这样写 `for (int i = 0; i < queue.size(); i++) {` 代码是不能通过测评的，这是因为 `queue.size()` 在循环中是变量（这条规则在 Python 中不成立，请各位读者自行验证）。正确的做法是：每一次在队列中取出元素的个数须要先暂存起来，请见参考代码；
  + 子结点入队的时候，非空的判断很重要：在队列的队首元素出队的时候，一定要在左（右）子结点非空的时候才将左（右）子结点入队。

+ 树的广度优先遍历的写法模式相对固定：

  + 使用队列；
  + 在队列非空的时候，动态取出队首元素；
  + 取出队首元素的时候，把队首元素相邻的结点（非空）加入队列。

大家在做题的过程中需要多加练习，融汇贯通，不须要死记硬背。

**参考代码**：

```Java []
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Solution {

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            // 注意 1：一定要先把当前队列的结点总数暂存起来
            int currentSize = queue.size();

            List<Integer> currentLevel = new ArrayList<>();
            for (int i = 0; i < currentSize; i++) {
                TreeNode front = queue.poll();
                currentLevel.add(front.val);
                // 注意 2：左（右）孩子结点非空才加入队列
                if (front.left != null) {
                    queue.offer(front.left);
                }
                if (front.right != null) {
                    queue.offer(front.right);
                }
            }
            res.add(currentLevel);
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是二叉树结点的个数，每个结点都访问一次，因此时间复杂度是 $O(N)$；
+ 空间复杂度：$O(N)$。

---

## 使用广度优先遍历得到无权图的最短路径

在 **无权图** 中，由于广度优先遍历本身的特点，假设源点为 `source`，只有在遍历到 **所有** 距离源点 `source`  的距离为 `d` 的所有结点以后，才能遍历到**所有** 距离源点 `source`  的距离为 `d + 1` 的所有结点。也可以使用「两点之间、线段最短」这条经验来辅助理解如下结论：从源点 `source` 到目标结点 `target` 走直线走过的路径一定是最短的。

---

## 图论中的最短路径问题概述

在图中，由于 **图中存在环**，和深度优先遍历一样，广度优先遍历也需要在遍历的时候记录已经遍历过的结点。**特别注意**：将结点添加到队列以后，**一定要马上标记为「已经访问」**，否则相同结点会重复入队，这一点在初学的时候很容易忽略。如果很难理解这样做的必要性，建议大家在代码中打印出队列中的元素进行调试：在图中，如果入队的时候不马上标记为「已访问」，相同的结点会重复入队，这是不对的。

另外一点还需要强调，广度优先遍历用于求解「**无权图**」的最短路径，因此一定要认清「无权图」这个前提条件。如果是带权图，就需要使用相应的专门的算法去解决它们。事实上，这些「专门」的算法的思想也都基于「广度优先遍历」的思想，我们为大家例举如下：

+ 带权有向图、且所有权重都非负的单源最短路径问题：使用 [Dijkstra 算法](https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989?fr=aladdin)；
+ 带权有向图的单源最短路径问题：[Bellman-Ford 算法](https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95)；
+ 一个图的所有结点对的最短路径问题：[Floy-Warshall 算法](https://baike.baidu.com/item/floyd-warshall%E7%AE%97%E6%B3%95/9705345)。

这里列出的以三位计算机科学家的名字命名的算法，大家可以在《算法导论》这本经典著作的第 24 章、第 25 章找到相关知识的介绍。值得说明的是：**应用任何一种算法，都需要认清使用算法的前提，不满足前提直接套用算法是不可取的**。**深刻理解应用算法的前提，也是学习算法的重要方法**。例如我们在学习「二分查找」算法、「滑动窗口」算法的时候，就可以问自己，这个问题为什么可以使用「二分查找」，为什么可以使用「滑动窗口」。我们知道一个问题可以使用「优先队列」解决，是什么样的需求促使我们想到使用「优先队列」，而不是「红黑树（平衡二叉搜索树）」，想清楚使用算法（数据结构）的前提更重要。

---


### 例 2：「力扣」第 323 题：无向图中连通分量的数目（中等，会员题）

给定编号从 `0` 到 `n-1` 的 `n` 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。

**示例 1**：

```
输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4 

输出: 2
```

**示例 2**：

```
输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

输出:  1
```

**注意**：
你可以假设在 `edges` 中不会出现重复的边。而且由于所以的边都是无向边，`[0, 1]` 与 `[1, 0]`  相同，所以它们不会同时在 `edges` 中出现。

**思路分析**：

+ 首先需要对输入数组进行处理，由于 `n` 个结点的编号从 `0` 到 `n - 1` ，因此可以使用「嵌套数组」表示邻接表，具体实现请见参考代码；
+ 然后遍历每一个顶点，对每一个顶点执行一次广度优先遍历，注意：在遍历的过程中使用 `visited` 布尔数组记录已经遍历过的结点。

**参考代码**：

```Java []
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Solution {

    public int countComponents(int n, int[][] edges) {
        // 第 1 步：构建图
        List<Integer>[] adj = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
        // 无向图，所以需要添加双向引用
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }

        // 第 2 步：开始广度优先遍历
        int res = 0;
        boolean[] visited = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                bfs(adj, i, visited);
                res++;
            }
        }
        return res;
    }

    /**
     * @param adj     邻接表
     * @param u       从 u 这个顶点开始广度优先遍历
     * @param visited 全局使用的 visited 布尔数组
     */
    private void bfs(List<Integer>[] adj, int u, boolean[] visited) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(u);
        visited[u] = true;

        while (!queue.isEmpty()) {
            Integer front = queue.poll();
            // 获得队首结点的所有后继结点
            List<Integer> successors = adj[front];
            for (int successor : successors) {
                if (!visited[successor]) {
                    queue.offer(successor);
                    // 特别注意：在加入队列以后一定要将该结点标记为访问，否则会出现结果重复入队的情况
                    visited[successor] = true;
                }
            }
        }
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(V + E)$，这里 $E$ 是边的条数，即数组 `edges` 的长度，初始化的时候遍历数组得到邻接表。这里 $V$ 为输入整数 `n`，遍历的过程是每一个结点执行一次深度优先遍历，时间复杂度为 $O(V)$；
+ 空间复杂度：$O(V + E)$，综合考虑邻接表 $O(V + E)$、`visited` 数组 $O(V)$、队列的长度 $O(V)$ 三者得到。

**说明**：和深度优先遍历一样，图的广度优先遍历的结果并不唯一，与每个结点的相邻结点的访问顺序有关。

---

## 练习

> 友情提示：第 1 - 4 题是广度优先遍历的变形问题，写对这些问题有助于掌握广度优先遍历的代码编写逻辑和细节。

1. 完成「力扣」第 107 题：二叉树的层次遍历 II（简单）；
2. 完成《剑指 Offer》第 32 - I 题：从上到下打印二叉树（中等）；
3. 完成《剑指 Offer》第 32 - III 题：从上到下打印二叉树 III（中等）；
4. 完成「力扣」第 103 题：二叉树的锯齿形层次遍历（中等）；
5. 完成「力扣」第 429 题：N 叉树的层序遍历（中等）；
6. 完成「力扣」第 993 题：二叉树的堂兄弟节点（中等）；

---


## 总结

+ 广度优先遍历可以用于「树」和「图」的问题的遍历；
+ 广度优先遍历作用于「无权图」，得到的是「最短路径」。如果题目有让求「最小」、「最短」、「最少」，可以考虑这个问题是不是可以建立成一个「图形结构」或者「树形结构」，用「广度优先遍历」的思想求得「最小」、「最短」、「最少」的数值；
+ 广度优先遍历作用于图论问题的时候，结点在加入队列以后标记为已经访问，否则会出现结点重复入队的情况。