# 第 4 节 拓扑排序

![image.png](https://pic.leetcode-cn.com/1611492476-lxssOa-image.png)

## 拓扑排序简介

拓扑排序（Topological Sorting）是一种应用在「有向无环图（DAG，Directed Acyclic Graph）」上，给出结点输出先后顺序的算法。拓扑排序不是给出大小关系的排序，而是给出先后顺序的一种算法。这些结点的输出顺序需要保证：

+ 每一个结点输出 **且仅输出一次**；
+ 在 **有向无环图** 中，如果存在一条从 `u` 到 `v` 的路径，那么在拓扑排序的结果中，`u` 必需保证在 `v` 的前面。

拓扑排序的经典应用是：课程安排和任务安排。以课程安排为例：《机器学习》这门课程的学习需要《微积分》、《线性代数》和《概率论与数理统计》作为基础。它们之间的关系可以用如下 **有向图** 表示。

![image.png](https://pic.leetcode-cn.com/1609313503-rURwnO-image.png){:width=500}

**拓扑排序的结果不唯一**，例如：`["微积分", "线性代数", "概率论与数理统计", "机器学习"]` 是一种拓扑排序的结果，`["概率论与数理统计", "微积分", "线性代数", "机器学习"]` 也是一种拓扑排序的结果。但一定保证「机器学习」安排在其它 $3$ 门课程的后面。

---

## 拓扑排序存在的前提

只有在 **有向无环图** 中，才存在拓扑排序。这是因为：

+ 「有向」是问题本身的要求，「有向」体现了完成一系列任务的先后顺序；
+ 为什么要求「无环」呢？图中存在环，说明有循环依赖，这一点可以这样理解：在一个圆圈中，我们不能说谁就一定在谁的前面。

![image.png](https://pic.leetcode-cn.com/1609648959-lhGjlI-image.png){:width=400}

---

## 拓扑排序的实现

拓扑排序有两种实现：

+ 深度优先遍历；
+ 广度优先遍历。

我们在「深度优先遍历」专题中有介绍如何使用「深度优先遍历」得到拓扑排序，这种思路比较冷门，不要求深入学习。

事实上，拓扑排序的更经典的实现是「广度优先遍历」。广度优先遍历在思想层面上更简单，编码也相对容易。还有一个好处：我们一直向大家强调了只有「有向无环图」才存在拓扑排序：
+ 用「深度优先遍历」得到拓扑序，**须要在遍历的过程中检测有向图是否存在环**；
+ 而应用「广度优先遍历」，我们只需要在有向图中执行一次广度优先遍历，在结束以后，就能够得到这个有向图是不是存在环，在不存在环的时候，输出拓扑排序的结果。也就是说，**广度优先遍历还可以帮助我们检测有向图是否存在环**。

我们以「力扣」第 1136 题（平行课程）为例，向大家介绍如何使用「广度优先遍历」实现「拓扑排序」。

## 例 1：「力扣」第 1136 题：平行课程（会员题，困难）

> 友情提示：这道问题虽然标注为困难，但是只要是学习过「拓扑排序」，就变得很容易了。如果没有学习过拓扑排序的朋友，可以把这道例题当作例题学习，拓扑排序的相关问题，代码编写是差不多的，如果不熟悉的朋友，需要多加练习。

已知有 `N` 门课程，它们以 `1` 到 `N` 进行编号。

给你一份课程关系表 `relations[i] = [X, Y]`，用以表示课程 `X` 和课程 `Y` 之间的先修关系：课程 `X` 必须在课程 `Y` 之前修完。

假设在一个学期里，你可以学习任何数量的课程，但前提是你已经学习了将要学习的这些课程的所有先修课程。

请你返回学完全部课程所需的最少学期数。

如果没有办法做到学完全部这些课程的话，就返回 `-1`。

**示例 1**：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/27/1316_ex1.png)

```
输入：N = 3, relations = [[1,3],[2,3]]
输出：2
解释：
在第一个学期学习课程 1 和 2，在第二个学期学习课程 3。
```

**示例 2**：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/27/1316_ex2.png)

```
输入：N = 3, relations = [[1,2],[2,3],[3,1]]
输出：-1
解释：
没有课程可以学习，因为它们相互依赖。
```

**提示**：

1. `1 <= N <= 5000`
2. `1 <= relations.length <= 5000`
3. `relations[i][0] != relations[i][1]`
4. 输入中没有重复的关系

**思路分析**：

+ 题目问「最少学期数」，可以想到是不是可以用「求解无权图的最短路径」的「广度优先遍历」的方法完成；
+ 广度优先遍历的思想是这样的：
  + 如果图中存在一个顶点（可以暂时认为这样的结点唯一，虽然不严谨，但并不影响对整个算法的理解），没有其它顶点指向它，**它一定是其它顶点的前驱结点，在拓扑排序的结果中，它应该排在最前面**；
  + 把这个没有其它顶点指向的结点删除了以后，对应的边需要删除，但事实上，我们不用真的在图中删除一条边。借助「入度数组」的概念（「入度」是指图中某个顶点被指向的次数之和），从图中删除一条 **有向边**，等价于 **有向边被指向的顶点的入度减 $1$**；
+ 拓扑排序算法的整个流程，就像是在剥洋葱一样，每一次都剥去「入度」为 $0$ 的顶点（同一层顶点之间的顺序无关紧要），一层层剥去的结点的顺序就组成了拓扑序。


<![1136.001.jpeg](https://pic.leetcode-cn.com/1609656704-QWNzNE-1136.001.jpeg),![1136.002.jpeg](https://pic.leetcode-cn.com/1609656704-rrkAjB-1136.002.jpeg),![1136.003.jpeg](https://pic.leetcode-cn.com/1609656704-mEQVuT-1136.003.jpeg),![1136.004.jpeg](https://pic.leetcode-cn.com/1609656704-SHOpNF-1136.004.jpeg),![1136.005.jpeg](https://pic.leetcode-cn.com/1609656704-wGVmJv-1136.005.jpeg),![1136.006.jpeg](https://pic.leetcode-cn.com/1609656704-OxxiMN-1136.006.jpeg)>


+ 拓扑排序的应用前提是在「有向无环图」中，如果图中存在环，那么环中的结点不会被输出，等价于：还有顶点的入度不为 $0$。

**参考代码**：

```Java []
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;

public class Solution {

    public int minimumSemesters(int N, int[][] relations) {
        // 第 1 步：初始化邻接表
        Set<Integer>[] adj = new HashSet[N + 1];
        for (int i = 1; i <= N; i++) {
            adj[i] = new HashSet<>();
        }
        // 构建邻接表、统计每个结点的入度
        int[] inDegree = new int[N + 1];
        for (int[] relation : relations) {
            inDegree[relation[1]]++;
            adj[relation[0]].add(relation[1]);
        }

        // 第 2 步：开始广度优先遍历
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= N; i++) {
            if (inDegree[i] == 0) {
                // 入度为 0 的所有顶点在拓扑排序的结果中位于其它顶点的前面
                queue.offer(i);
            }
        }

        int step = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Integer top = queue.poll();

                Set<Integer> successors = adj[top];
                for (int successor : successors) {
                    // 删除一条边，等价于被指向结点的入度减 1
                    inDegree[successor]--;
                    // 如果入度减 1 以后为 0，该结点就是接下来要遍历到的结点
                    if (inDegree[successor] == 0) {
                        queue.offer(successor);
                    }
                }
            }
            step++;
        }

        // 第 3 步：如果还有一些顶点有边指向它，说明图中存在环
        for (int i = 1; i <= N; i++) {
            if (inDegree[i] > 0) {
                return -1;
            }
        }
        return step;
    }
}
```

**复杂度分析：**

+ 时间复杂度：$O(E + V)$。这里 $E$ 表示邻边的条数，$V$ 表示结点的个数。初始化入度为 $0$ 的集合需要遍历整张图，具体做法是检查每个结点和每条边，因此复杂度为 $O(E+V)$，然后对该集合进行操作，又需要遍历整张图中的每个结点和每条边，复杂度也为 $O(E+V)$；
+ 空间复杂度：$O(V)$：入度数组、邻接表的长度都是结点的个数 $V$，即使使用队列，队列最长的时候也不会超过 $V$，因此空间复杂度是 $O(V)$。

> 友情提示：大家做完这道题可以想一想，为什么「拓扑排序」的「广度优先遍历」没有使用 `visited` 数组。这是因为 ① 「拓扑排序」需要在「有向无环图」的前提下才能得到拓扑排序的结果；② 而 `visited` 数组的作用正是因为图中有环，才需要使用它记住已经遍历过的顶点，但是「有向无环图」恰好是没有环的，因此无需使用 `visited` 数组；③ 入度数组恰好起到了 `visited` 数组的作用，如果在遍历完成以后，还存在入度不为 $0$ 的顶点，则说明图中存在环，不能到拓扑序。

## 例 2：「力扣」第 269 题：火星词典（会员题，困难）

现有一种使用字母的全新语言，这门语言的字母顺序与英语顺序不同。

假设，您并不知道其中字母之间的先后顺序。但是，会收到词典中获得一个 不为空的 单词列表。因为是从词典中获得的，所以该单词列表内的单词已经 按这门新语言的字母顺序进行了排序。

您需要根据这个输入的列表，还原出此语言中已知的字母顺序。

**示例 1**：

```
输入:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]
输出: "wertf"
```

**示例 2**：

```
输入:
[
  "z",
  "x"
]
输出: "zx"
```

**示例 3**：

```
输入:
[
  "z",
  "x",
  "z"
] 
输出: "" 
解释: 此顺序是非法的，因此返回 ""。
```

**提示**：

- 你可以默认输入的全部都是小写字母
- 若给定的顺序是不合法的，则返回空字符串即可
- 若存在多种可能的合法字母顺序，请返回其中任意一种顺序即可

**思路分析**：

+ 首先需要明确题目的意思，这道题给出了一个按照「自定义字典序」排序的单词列表，让我们还原出「自定义的字典序」（题目中说的火星词典）；

+ 字典序：是指按照单词出现在字典的顺序进行排序的方法。先按照第一个字母以 a、b、c......z 的顺序排列，如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长，比如 sigh 和 sight），把短者排在前；

+ 分析示例 1：`["wrt", "wrf", "er", "ett", "rftt"]`，

  + 比较 `"wrt"` 与 `"wrf`，**按数位依次比较**，前 $2$ 个字符相等，`t` 与 `f` 不等，说明 `t` 的字典序在 `f` 的前面，我们记为 `t -> f`；
  + 比较 `"wrf"` 与 `"er"`，**按数位依次比较**，`w` 与 `e` 不等，说明 `w` 的字典序在 `e` 的前面，我们记为 `w -> e`；
  + 比较 `"er"` 与 `"ett"`，**按数位依次比较**，前 $1$ 个字符相等，`r` 与 `t` 不等，说明 `r` 的字典序在 `t` 的前面，我们记为 `r -> t`；
  + 比较 `"ett"` 与 `"rftt"`，**按数位依次比较**，`e` 与 `r` 不等，说明 `e` 的字典序在 `r` 的前面，我们记为 `e -> r`；

把它们连在一起，可以画出如下图结构：

![image.png](https://pic.leetcode-cn.com/1609382469-MDmGwe-image.png){:width=500}

因此输出就是 `"wertf"`。

+ 通过示例 1 的分析，可以归纳出求解这个问题的步骤：
  + 步骤 1：通过输入的字符串数组 `words` ，构建字符的图结构（建图）；
  + 步骤 2：可以对步骤 1 得到的图结构执行一次「拓扑排序」（广度优先遍历），如果图是 **有向无环图**，拓扑排序的结果就是「自定义字典序」。
+ 在实际编码的时候，有很多细节和一些特殊的测试用例需要考虑，我们例举如下（大家不一定需要了解下面说到的细节，可以先自己尝试编码，在遇到问题的时候尝试调试，这样是更有效的）：
  + 建图，建立邻接表，即「顶点」和它的 **所有** 「后继」结点的对应关系，题目中说：「你可以默认输入的全部都是小写字母」，因此可以使用数组或者哈希表，这里推荐使用哈希表，理由是 ① 哈希表有去重、判重的功能；②  有遍历所有在输入字符串数组中出现的字符的需求，遍历哈希表中的所有键，是相对方便的；
  + 针对特殊测试用例，`["abc", "ab"]`，按照字典序的定义，长度较短的字符串在前，应该为 `["ab", "abc"]`，在建图的时候需要考虑到这种特殊的情况；
  + 建图的时候，需要找到找到位置相邻的一对单词，从左至右依次比较，**直到找到不一样的字符，得到有向图的一条边**，后面就不可以再比较下去（回顾上述字典序的定义）；
  + 题目中说：「你可以默认输入的全部都是小写字母」，因此在拓扑排序中使用的入度数组的长度可以只设置为 $26$。注意：在输入的字符串数组中，$26$ 个字符不一定都会出现，不会出现的字符在入度数组里的入度也为 $0$，在编码的时候需要考虑到这种情况；
  + 构建图的时候，有向边的可以被重复添加，因为哈希表可以去重，但是被指向顶点的入度不可以重复增加，为此需要做特殊判断；
  + 拓扑排序以后，需要判断：所有的顶点都输出了，才是说明通过输入字符串数组构建的图结构是有向无环图，此时才输出拓扑排序的结果。

**参考代码**：

```Java []
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class Solution {

    public String alienOrder(String[] words) {
        int len = words.length;
        if (len == 0) {
            return "";
        }

        // 第 1 步：构建图与统计入度数组
        Map<Character, Set<Character>> adj = new HashMap<>(26);
        for (String word : words) {
            for (char c : word.toCharArray()) {
                // 如果 c 还未在哈希表的 key 中出现，创建 key，并且初始化它的后继结点列表
                adj.putIfAbsent(c, new HashSet<>());
            }
        }

        int[] inDegree = new int[26];
        // 相邻两个单词比较，得出字典序
        for (int i = 0; i < len - 1; i++) {
            char[] charArray1 = words[i].toCharArray();
            char[] charArray2 = words[i + 1].toCharArray();

            int minLen = Math.min(charArray1.length, charArray2.length);
            for (int j = 0; j < minLen; j++) {
                if (charArray1[j] != charArray2[j]) {
                    // 有向边的可以被重复添加，因为哈希表可以去重，但是被指向顶点的入度不可以重复增加，为此需要做特殊判断
                    if (!adj.get(charArray1[j]).contains(charArray2[j])) {
                        adj.get(charArray1[j]).add(charArray2[j]);
                        inDegree[charArray2[j] - 'a']++;
                    }
                    // 这个 break 很重要，后面的字符不可以继续比对下去
                    break;
                }

                // 针对特殊测试用例，["abc", "ab"]，不存在这样的字典序排序结果
                if (j == minLen - 1 && words[i].length() > words[i + 1].length()) {
                    return "";
                }
            }
        }

        // 第 2 步：基于 adj 和入度数组进行广度优先遍历，下面这一串代码是典型的拓扑排序的代码
        Queue<Character> queue = new LinkedList<>();
        for (char c : adj.keySet()) {
            if (inDegree[c - 'a'] == 0) {
                queue.offer(c);
            }
        }

        StringBuilder stringBuilder = new StringBuilder();
        while (!queue.isEmpty()) {
            Character top = queue.poll();
            stringBuilder.append(top);

            Set<Character> successors = adj.get(top);
            for (Character successor : successors) {
                inDegree[successor - 'a']--;
                if (inDegree[successor - 'a'] == 0) {
                    queue.offer(successor);
                }
            }
        }

        // 最后不要忘了，所有的顶点都输出了，才是有向无环图
        // 可以遍历入度数组，如果存在一个顶点的入度大于 0，说明存在环，输出 ""
        // 等价的方式是看输出的字符串长度是否等于 adj 的键值对总数
        if (stringBuilder.length() == adj.size()) {
            return stringBuilder.toString();
        }
        return "";
    }
}
```

**复杂度分析**：

本题的复杂度分析较难给出形式化的结论，我们知道拓扑排序，其实就是在问题所对应的图形结构上执行一次广度优先遍历，广度优先遍历的时间复杂度取决于图形结构的顶点数和边数。

+ 时间复杂度：
  + 当前这个问题，构建图之前需要遍历字符串数组的每一个字符串，然后构建图的时候，需要枚举所有输入字符串数组「相邻的」两个字符串的字符（出了第一个字符串和最后一个字符串以外，每隔字符串被遍历了两次），可以粗略地认为所有字符串都被遍历了两次。因此时间复杂度主要由以下关系决定：
    + 输入字符串数组的所有字符的总数（包含了重复字符）；
    + 输入字符串数组所包含的不重复字符数，根据题目意思，这个值不超过 $26$；
    + 输入字符串数组所构建的图形结构的 **有向边** 的总数，根据题目意思， 这个值不超过 $25!$。
+ 空间复杂度：题目中用到的空间来自「邻接表 `adj`」（较难给出形式化的表达式） 和入度数组 `inDegree`（长度为 $26$）。

---


## 练习

1. 完成「力扣」第 207 题：课程表（中等）；
2. 完成「力扣」第 210 题：课程表 II（中等）；
3. 完成「力扣」第 301 题：最小高度树（中等）；
4. 完成「力扣」第 1245 题：树的直径（中等）；
5. 完成「力扣」第 802 题：找到最终的安全状态（中等）；
6. 完成「力扣」第 630 题：课程表 III（困难）；
7. 完成「力扣」第 1203 题：项目管理（困难）。

---

## 总结

+ 拓扑排序应用于 **有向图** 检测是否有环，**有向无环图才存在拓扑序**；
+ 拓扑序结果不唯一；
+ 拓扑排序的典型实现是「广度优先遍历」，使用「入度数组」和「队列」帮助实现；
+ 代码的写法是相对固定的，需要在理解「广度优先遍历」思想的前提下，加以练习。
